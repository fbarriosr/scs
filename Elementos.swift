//
//  Elementos.swift
//  com.RentalApps.Suggested-Cannula-Size
//
//  Created by PixelCut on 11-06-17.
//  Copyright Â© 2017 PixelCut. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class Elementos : NSObject {

    //// Drawing Methods

    public dynamic class func drawCanvas2(frame: CGRect = CGRect(x: 0, y: -0, width: 430, height: 81), click1: Bool = true, line: Bool = true, click2: Bool = true, click3: Bool = true, lineWidthValue: CGFloat = 164) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let fillColor = UIColor(red: 0.247, green: 0.286, blue: 0.349, alpha: 1.000)
        let fillColor2 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let strokeColor = UIColor(red: 0.325, green: 0.373, blue: 0.439, alpha: 1.000)
        let fillColor3 = UIColor(red: 0.328, green: 0.371, blue: 0.441, alpha: 1.000)
        let textForeground2 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Variable Declarations
        let expression: CGFloat = lineWidthValue < 0 ? 0 : (lineWidthValue > 161 ? 161 : lineWidthValue)


        //// Subframes
        let group7: CGRect = CGRect(x: frame.minX + fastFloor((frame.width - 205.85) * 0.47736 + 0.5), y: frame.minY + fastFloor((frame.height - 31) * 0.40000 + 0.5), width: 205.85, height: 31)


        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(rect: CGRect(x: frame.minX, y: frame.minY, width: fastFloor((frame.width) * 1.00000 + 0.5), height: fastFloor((frame.height) * 1.00000 + 0.5)))
        fillColor.setFill()
        rectanglePath.fill()


        //// Group 7
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: group7.minX + 6.24, y: group7.minY + 15.42))
        bezierPath.addLine(to: CGPoint(x: group7.minX + 199.76, y: group7.minY + 15.42))
        strokeColor.setStroke()
        bezierPath.lineWidth = 8.59
        bezierPath.lineCapStyle = .square
        bezierPath.stroke()


        //// Group 6
        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: group7.minX + 175.45, y: group7.minY, width: 30.4, height: 31))
        fillColor3.setFill()
        ovalPath.fill()


        //// Label Drawing
        let labelRect = CGRect(x: group7.minX + 186.89, y: group7.minY + 2, width: 7.99, height: 24)
        let labelTextContent = "3"
        let labelStyle = NSMutableParagraphStyle()
        labelStyle.alignment = .center
        let labelFontAttributes = [NSFontAttributeName: UIFont(name: "OpenSans-Bold", size: 14)!, NSForegroundColorAttributeName: textForeground2, NSParagraphStyleAttributeName: labelStyle]

        let labelTextHeight: CGFloat = labelTextContent.boundingRect(with: CGSize(width: labelRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: labelFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: labelRect)
        labelTextContent.draw(in: CGRect(x: labelRect.minX, y: labelRect.minY + (labelRect.height - labelTextHeight) / 2, width: labelRect.width, height: labelTextHeight), withAttributes: labelFontAttributes)
        context.restoreGState()




        //// Group 5
        //// Oval 2 Drawing
        let oval2Path = UIBezierPath(ovalIn: CGRect(x: group7.minX + 88.35, y: group7.minY, width: 30.4, height: 31))
        fillColor3.setFill()
        oval2Path.fill()


        //// Label 2 Drawing
        let label2Rect = CGRect(x: group7.minX + 98.89, y: group7.minY + 2, width: 7.99, height: 24)
        let label2TextContent = "2"
        let label2Style = NSMutableParagraphStyle()
        label2Style.alignment = .center
        let label2FontAttributes = [NSFontAttributeName: UIFont(name: "OpenSans-Bold", size: 14)!, NSForegroundColorAttributeName: textForeground2, NSParagraphStyleAttributeName: label2Style]

        let label2TextHeight: CGFloat = label2TextContent.boundingRect(with: CGSize(width: label2Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: label2FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: label2Rect)
        label2TextContent.draw(in: CGRect(x: label2Rect.minX, y: label2Rect.minY + (label2Rect.height - label2TextHeight) / 2, width: label2Rect.width, height: label2TextHeight), withAttributes: label2FontAttributes)
        context.restoreGState()




        //// Group 4
        //// Oval 3 Drawing
        let oval3Path = UIBezierPath(ovalIn: CGRect(x: group7.minX, y: group7.minY, width: 30.4, height: 31))
        fillColor3.setFill()
        oval3Path.fill()


        //// Label 3 Drawing
        let label3Rect = CGRect(x: group7.minX + 10.89, y: group7.minY + 2, width: 7.99, height: 24)
        let label3TextContent = "1"
        let label3Style = NSMutableParagraphStyle()
        label3Style.alignment = .center
        let label3FontAttributes = [NSFontAttributeName: UIFont(name: "OpenSans-Bold", size: 14)!, NSForegroundColorAttributeName: textForeground2, NSParagraphStyleAttributeName: label3Style]

        let label3TextHeight: CGFloat = label3TextContent.boundingRect(with: CGSize(width: label3Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: label3FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: label3Rect)
        label3TextContent.draw(in: CGRect(x: label3Rect.minX, y: label3Rect.minY + (label3Rect.height - label3TextHeight) / 2, width: label3Rect.width, height: label3TextHeight), withAttributes: label3FontAttributes)
        context.restoreGState()




        if (line) {
            //// Rectangle 2 Drawing
            let rectangle2Path = UIBezierPath(rect: CGRect(x: 131, y: 35, width: expression, height: 2))
            fillColor2.setFill()
            rectangle2Path.fill()
        }


        //// Group 3
        if (click3) {
            //// Oval 6 Drawing
            let oval6Path = UIBezierPath(ovalIn: CGRect(x: group7.minX + 182, y: group7.minY + 6, width: 18.7, height: 18.6))
            fillColor2.setFill()
            oval6Path.fill()


            //// Bezier 3 Drawing
            let bezier3Path = UIBezierPath()
            bezier3Path.move(to: CGPoint(x: group7.minX + 195.87, y: group7.minY + 12.16))
            bezier3Path.addCurve(to: CGPoint(x: group7.minX + 195.24, y: group7.minY + 12.16), controlPoint1: CGPoint(x: group7.minX + 195.7, y: group7.minY + 12), controlPoint2: CGPoint(x: group7.minX + 195.41, y: group7.minY + 12))
            bezier3Path.addLine(to: CGPoint(x: group7.minX + 188.95, y: group7.minY + 18.01))
            bezier3Path.addLine(to: CGPoint(x: group7.minX + 186.19, y: group7.minY + 15.46))
            bezier3Path.addCurve(to: CGPoint(x: group7.minX + 185.56, y: group7.minY + 15.46), controlPoint1: CGPoint(x: group7.minX + 186.02, y: group7.minY + 15.3), controlPoint2: CGPoint(x: group7.minX + 185.74, y: group7.minY + 15.3))
            bezier3Path.addCurve(to: CGPoint(x: group7.minX + 185.56, y: group7.minY + 16.04), controlPoint1: CGPoint(x: group7.minX + 185.39, y: group7.minY + 15.62), controlPoint2: CGPoint(x: group7.minX + 185.39, y: group7.minY + 15.88))
            bezier3Path.addLine(to: CGPoint(x: group7.minX + 188.64, y: group7.minY + 18.88))
            bezier3Path.addCurve(to: CGPoint(x: group7.minX + 189.27, y: group7.minY + 18.88), controlPoint1: CGPoint(x: group7.minX + 188.81, y: group7.minY + 19.04), controlPoint2: CGPoint(x: group7.minX + 189.1, y: group7.minY + 19.04))
            bezier3Path.addLine(to: CGPoint(x: group7.minX + 195.87, y: group7.minY + 12.75))
            bezier3Path.addCurve(to: CGPoint(x: group7.minX + 195.87, y: group7.minY + 12.16), controlPoint1: CGPoint(x: group7.minX + 196.04, y: group7.minY + 12.59), controlPoint2: CGPoint(x: group7.minX + 196.04, y: group7.minY + 12.32))
            bezier3Path.addCurve(to: CGPoint(x: group7.minX + 195.87, y: group7.minY + 12.16), controlPoint1: CGPoint(x: group7.minX + 195.7, y: group7.minY + 12), controlPoint2: CGPoint(x: group7.minX + 196.04, y: group7.minY + 12.32))
            bezier3Path.close()
            bezier3Path.usesEvenOddFillRule = true
            fillColor.setFill()
            bezier3Path.fill()
        }




        //// Group
        if (click2) {
            //// Oval 5 Drawing
            let oval5Path = UIBezierPath(ovalIn: CGRect(x: group7.minX + 93.65, y: group7.minY + 6.2, width: 18.7, height: 18.6))
            fillColor2.setFill()
            oval5Path.fill()


            //// Bezier 4 Drawing
            let bezier4Path = UIBezierPath()
            bezier4Path.move(to: CGPoint(x: group7.minX + 107.87, y: group7.minY + 12.16))
            bezier4Path.addCurve(to: CGPoint(x: group7.minX + 107.24, y: group7.minY + 12.16), controlPoint1: CGPoint(x: group7.minX + 107.7, y: group7.minY + 12), controlPoint2: CGPoint(x: group7.minX + 107.41, y: group7.minY + 12))
            bezier4Path.addLine(to: CGPoint(x: group7.minX + 100.95, y: group7.minY + 18.01))
            bezier4Path.addLine(to: CGPoint(x: group7.minX + 98.19, y: group7.minY + 15.46))
            bezier4Path.addCurve(to: CGPoint(x: group7.minX + 97.56, y: group7.minY + 15.46), controlPoint1: CGPoint(x: group7.minX + 98.02, y: group7.minY + 15.3), controlPoint2: CGPoint(x: group7.minX + 97.74, y: group7.minY + 15.3))
            bezier4Path.addCurve(to: CGPoint(x: group7.minX + 97.56, y: group7.minY + 16.04), controlPoint1: CGPoint(x: group7.minX + 97.39, y: group7.minY + 15.62), controlPoint2: CGPoint(x: group7.minX + 97.39, y: group7.minY + 15.88))
            bezier4Path.addLine(to: CGPoint(x: group7.minX + 100.64, y: group7.minY + 18.88))
            bezier4Path.addCurve(to: CGPoint(x: group7.minX + 101.27, y: group7.minY + 18.88), controlPoint1: CGPoint(x: group7.minX + 100.81, y: group7.minY + 19.04), controlPoint2: CGPoint(x: group7.minX + 101.1, y: group7.minY + 19.04))
            bezier4Path.addLine(to: CGPoint(x: group7.minX + 107.87, y: group7.minY + 12.75))
            bezier4Path.addCurve(to: CGPoint(x: group7.minX + 107.87, y: group7.minY + 12.16), controlPoint1: CGPoint(x: group7.minX + 108.04, y: group7.minY + 12.59), controlPoint2: CGPoint(x: group7.minX + 108.04, y: group7.minY + 12.32))
            bezier4Path.addCurve(to: CGPoint(x: group7.minX + 107.87, y: group7.minY + 12.16), controlPoint1: CGPoint(x: group7.minX + 107.7, y: group7.minY + 12), controlPoint2: CGPoint(x: group7.minX + 108.04, y: group7.minY + 12.32))
            bezier4Path.close()
            bezier4Path.usesEvenOddFillRule = true
            fillColor.setFill()
            bezier4Path.fill()
        }




        //// Group 2
        if (click1) {
            //// Oval 4 Drawing
            let oval4Path = UIBezierPath(ovalIn: CGRect(x: group7.minX + 6.25, y: group7.minY + 6.2, width: 18.7, height: 18.6))
            fillColor2.setFill()
            oval4Path.fill()


            //// Bezier 5 Drawing
            let bezier5Path = UIBezierPath()
            bezier5Path.move(to: CGPoint(x: group7.minX + 19.87, y: group7.minY + 12.16))
            bezier5Path.addCurve(to: CGPoint(x: group7.minX + 19.24, y: group7.minY + 12.16), controlPoint1: CGPoint(x: group7.minX + 19.7, y: group7.minY + 12), controlPoint2: CGPoint(x: group7.minX + 19.41, y: group7.minY + 12))
            bezier5Path.addLine(to: CGPoint(x: group7.minX + 12.95, y: group7.minY + 18.01))
            bezier5Path.addLine(to: CGPoint(x: group7.minX + 10.19, y: group7.minY + 15.46))
            bezier5Path.addCurve(to: CGPoint(x: group7.minX + 9.56, y: group7.minY + 15.46), controlPoint1: CGPoint(x: group7.minX + 10.02, y: group7.minY + 15.3), controlPoint2: CGPoint(x: group7.minX + 9.74, y: group7.minY + 15.3))
            bezier5Path.addCurve(to: CGPoint(x: group7.minX + 9.56, y: group7.minY + 16.04), controlPoint1: CGPoint(x: group7.minX + 9.39, y: group7.minY + 15.62), controlPoint2: CGPoint(x: group7.minX + 9.39, y: group7.minY + 15.88))
            bezier5Path.addLine(to: CGPoint(x: group7.minX + 12.64, y: group7.minY + 18.88))
            bezier5Path.addCurve(to: CGPoint(x: group7.minX + 13.27, y: group7.minY + 18.88), controlPoint1: CGPoint(x: group7.minX + 12.81, y: group7.minY + 19.04), controlPoint2: CGPoint(x: group7.minX + 13.1, y: group7.minY + 19.04))
            bezier5Path.addLine(to: CGPoint(x: group7.minX + 19.87, y: group7.minY + 12.75))
            bezier5Path.addCurve(to: CGPoint(x: group7.minX + 19.87, y: group7.minY + 12.16), controlPoint1: CGPoint(x: group7.minX + 20.04, y: group7.minY + 12.59), controlPoint2: CGPoint(x: group7.minX + 20.04, y: group7.minY + 12.32))
            bezier5Path.addCurve(to: CGPoint(x: group7.minX + 19.87, y: group7.minY + 12.16), controlPoint1: CGPoint(x: group7.minX + 19.7, y: group7.minY + 12), controlPoint2: CGPoint(x: group7.minX + 20.04, y: group7.minY + 12.32))
            bezier5Path.close()
            bezier5Path.usesEvenOddFillRule = true
            fillColor.setFill()
            bezier5Path.fill()
        }
    }

    public dynamic class func drawCanvas4(frame: CGRect = CGRect(x: 0, y: 0, width: 369, height: 371)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let fillColor = UIColor(red: 0.247, green: 0.286, blue: 0.349, alpha: 1.000)
        let fillColor2 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let shadowTint = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)

        //// Shadow Declarations
        let shadow = NSShadow()
        shadow.shadowColor = shadowTint.withAlphaComponent(0.5 * shadowTint.cgColor.alpha)
        shadow.shadowOffset = CGSize(width: 906, height: 4)
        shadow.shadowBlurRadius = 11


        //// Subframes
        let group2: CGRect = CGRect(x: frame.minX, y: frame.minY, width: fastFloor((frame.width) * 1.00000 + 0.5), height: fastFloor((frame.height) * 1.00000 + 0.5))


        //// Group 2
        //// Group 3
        context.saveGState()
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        //// Clip Clip 2
        let clip2Path = UIBezierPath(roundedRect: CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 1.00000 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5)), cornerRadius: 20)
        clip2Path.addClip()


        //// Group 4
        context.saveGState()
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        //// Clip Clip
        let clipPath = UIBezierPath(rect: CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 1.00000 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00270 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5)))
        clipPath.addClip()


        //// Rectangle 2 Drawing
        let rectangle2Path = UIBezierPath(roundedRect: CGRect(x: group2.minX + fastFloor(group2.width * -2.45528 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * -1.45528 + 0.5) - fastFloor(group2.width * -2.45528 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5)), cornerRadius: 20)
        context.saveGState()
        context.setShadow(offset: shadow.shadowOffset, blur: shadow.shadowBlurRadius, color: (shadow.shadowColor as! UIColor).cgColor)
        fillColor2.setFill()
        rectangle2Path.fill()
        context.restoreGState()



        context.endTransparencyLayer()
        context.restoreGState()


        //// Rectangle 4 Drawing
        let rectangle4Path = UIBezierPath(rect: CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 1.00000 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00270 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5)))
        fillColor.setFill()
        rectangle4Path.fill()


        context.endTransparencyLayer()
        context.restoreGState()


        //// Rectangle 6 Drawing
        let rectangle6Path = UIBezierPath(roundedRect: CGRect(x: group2.minX + fastFloor(group2.width * 0.15989 + 0.5), y: group2.minY + fastFloor(group2.height * 0.76280 + 0.5), width: fastFloor(group2.width * 0.83740 + 0.5) - fastFloor(group2.width * 0.15989 + 0.5), height: fastFloor(group2.height * 0.92992 + 0.5) - fastFloor(group2.height * 0.76280 + 0.5)), cornerRadius: 31)
        fillColor2.setFill()
        rectangle6Path.fill()
    }

    public dynamic class func drawCanvas5(frame: CGRect = CGRect(x: 0, y: 0, width: 423, height: 81)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let fillColor = UIColor(red: 0.247, green: 0.286, blue: 0.349, alpha: 1.000)
        let fillColor2 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(rect: CGRect(x: frame.minX, y: frame.minY, width: fastFloor((frame.width) * 1.00236 + 0.5), height: fastFloor((frame.height) * 1.00000 + 0.5)))
        fillColor.setFill()
        rectanglePath.fill()


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: frame.minX + 0.85673 * frame.width, y: frame.minY + 0.64338 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.86100 * frame.width, y: frame.minY + 0.52632 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.86271 * frame.width, y: frame.minY + 0.61342 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.86473 * frame.width, y: frame.minY + 0.56775 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.83361 * frame.width, y: frame.minY + 0.47624 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.85615 * frame.width, y: frame.minY + 0.47530 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.84386 * frame.width, y: frame.minY + 0.45283 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.83026 * frame.width, y: frame.minY + 0.48477 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.82878 * frame.width, y: frame.minY + 0.46741 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.81708 * frame.width, y: frame.minY + 0.41487 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.82641 * frame.width, y: frame.minY + 0.44109 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.82202 * frame.width, y: frame.minY + 0.42391 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.80139 * frame.width, y: frame.minY + 0.41733 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.81213 * frame.width, y: frame.minY + 0.40582 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.80657 * frame.width, y: frame.minY + 0.40482 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.79142 * frame.width, y: frame.minY + 0.55485 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.79102 * frame.width, y: frame.minY + 0.44236 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.78689 * frame.width, y: frame.minY + 0.50260 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.80974 * frame.width, y: frame.minY + 0.76789 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.85104 * frame.width, y: frame.minY + 0.66384 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.85673 * frame.width, y: frame.minY + 0.64339 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.85320 * frame.width, y: frame.minY + 0.65843 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.85511 * frame.width, y: frame.minY + 0.65148 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.85542 * frame.width, y: frame.minY + 0.64849 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.83188 * frame.width, y: frame.minY + 0.64776 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.83043 * frame.width, y: frame.minY + 0.61857 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.82578 * frame.width, y: frame.minY + 0.71344 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.82215 * frame.width, y: frame.minY + 0.55216 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.81866 * frame.width, y: frame.minY + 0.66673 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.81604 * frame.width, y: frame.minY + 0.63097 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.81372 * frame.width, y: frame.minY + 0.64995 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.79963 * frame.width, y: frame.minY + 0.64995 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.79919 * frame.width, y: frame.minY + 0.64411 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.81357 * frame.width, y: frame.minY + 0.64411 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.81604 * frame.width, y: frame.minY + 0.61857 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.81837 * frame.width, y: frame.minY + 0.65068 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.82215 * frame.width, y: frame.minY + 0.51495 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.82578 * frame.width, y: frame.minY + 0.69227 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.83043 * frame.width, y: frame.minY + 0.59960 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.83261 * frame.width, y: frame.minY + 0.64411 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.85673 * frame.width, y: frame.minY + 0.64338 * frame.height))
        bezierPath.close()
        bezierPath.usesEvenOddFillRule = true
        fillColor2.setFill()
        bezierPath.fill()
    }

}
